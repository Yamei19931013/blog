<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>优秀的 blossomsun</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="优秀的 blossomsun">
<meta property="og:url" content="https://github.com/blossomsun/blog/index.html">
<meta property="og:site_name" content="优秀的 blossomsun">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="blossomsun">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="优秀的 blossomsun" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/blog/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">优秀的 blossomsun</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/blossomsun/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-5.3.3 全家桶之 axios" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/08/22/5.3.3%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20axios/" class="article-date">
  <time datetime="2020-08-22T15:28:52.000Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/08/22/5.3.3%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20axios/">全家桶之 axios</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、什么是-axios"><a href="#一、什么是-axios" class="headerlink" title="一、什么是 axios?"></a>一、什么是 axios?</h2><p>官方定义：axios 是一个基于 promise（是一个对象用来传递异步操作的信息） 的 HTTP 库，可以用在浏览器和 node.js 中。<br>简单地说：axios 是用来实现页面和web服务器之间数据的异步传输。<br>axios出现之前，我们实现页面和web服务器之间数据的交互方法有ajax、fetch。</p>
<h4 id="ajax、axios、fetch的区别："><a href="#ajax、axios、fetch的区别：" class="headerlink" title="ajax、axios、fetch的区别："></a>ajax、axios、fetch的区别：</h4><h5 id="1、ajax"><a href="#1、ajax" class="headerlink" title="1、ajax"></a>1、ajax</h5><p>1.1 传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。<br>JQuery ajax 是对原生XHR的封装，除此以外还增添了对JSONP的支持。</p>
<p>1.2 缺点：<br>1）本身是针对MVC的编程,不符合现在前端MVVM的浪潮<br>2）基于原生的XHR开发，XHR本身的架构不清晰。<br>3）JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）<br>4）不符合关注分离（Separation of Concerns）的原则<br>5）配置和调用方式非常混乱，而且基于事件的异步模型不友好。</p>
<h5 id="2、axios"><a href="#2、axios" class="headerlink" title="2、axios"></a>2、axios</h5><p>2.1 axios 本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范。</p>
<p>2.2 特征：<br>1）从浏览器中创建 XMLHttpRequest<br>2）支持 Promise API<br>3）客户端支持防止CSRF<br>4）提供了一些并发请求的接口（重要，方便了很多的操作）<br>5）从 node.js 创建 http 请求<br>6）拦截请求和响应<br>7）转换请求和响应数据<br>8）取消请求<br>9）自动转换JSON数据</p>
<h5 id="3-fetch"><a href="#3-fetch" class="headerlink" title="3.fetch"></a>3.fetch</h5><p>3.1<br>fetch是在ES6出现的，使用了ES6中的promise对象，是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。</p>
<p>3.2 优点<br> 1） 语法简洁，更加语义化<br> 2） 基于标准 Promise 实现，支持 async/await<br> 3） 同构方便，使用 <a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a><br> 4） 更加底层，提供的API丰富（request, response）<br> 5） 脱离了XHR，是ES规范里新的实现方式</p>
<p>3.3 缺点<br> 1）fetch的兼容性并不太好,ie 和 safari 都不支持；<br> 2）fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装；</p>
<h2 id="一、axios-如何使用"><a href="#一、axios-如何使用" class="headerlink" title="一、axios 如何使用?"></a>一、axios 如何使用?</h2><h5 id="1、拦截器设置"><a href="#1、拦截器设置" class="headerlink" title="1、拦截器设置"></a>1、拦截器设置</h5> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 添加请求拦截器</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h5 id="2、上传文件处理"><a href="#2、上传文件处理" class="headerlink" title="2、上传文件处理"></a>2、上传文件处理</h5><p> creat一个纯净的axios请求，挂载到vue原型里</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2020/08/22/5.3.3%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20axios/" data-id="ckefjrla0000ms0sx4kr7832c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/vue-%E5%85%A8%E5%AE%B6%E6%A1%B6/" rel="tag">vue 全家桶</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-5.3.2 全家桶之 Vue-Router" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/08/22/5.3.2%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20Vue-Router/" class="article-date">
  <time datetime="2020-08-22T13:57:50.000Z" itemprop="datePublished">2020-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/08/22/5.3.2%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20Vue-Router/">全家桶之 Vue Router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、什么是-Vue-Router"><a href="#一、什么是-Vue-Router" class="headerlink" title="一、什么是 Vue Router?"></a>一、什么是 Vue Router?</h2><p>Vue Router 就是路由管理器。</p>
<p>路由中的三个基本的概念：<br>1、route：一条路由；<br>2、routes： 是一组路由；<br>3、router: 一个机制，相当于一个管理者，来管理路由；</p>
<p>客户端路由有两种实现方式（vue-router的model有两种模式）：<br>1、基于hash ；<br>2、基于html5 history api；</p>
<h2 id="二、为什么要用-Vue-Router"><a href="#二、为什么要用-Vue-Router" class="headerlink" title="二、为什么要用 Vue Router?"></a>二、为什么要用 Vue Router?</h2><p>解决路由切换，路由拦截等问题</p>
<h2 id="三、Vue-Router-基本用法"><a href="#三、Vue-Router-基本用法" class="headerlink" title="三、Vue Router 基本用法?"></a>三、Vue Router 基本用法?</h2><p>1、安装并导入 vue-router 组件类库：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入 vue-router 组件类库 --&gt;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br></pre></td></tr></table></figure>
<p>2、使用 router-link 组件来导航</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link tag=<span class="string">&quot;div&quot;</span> to=<span class="string">&quot;/login&quot;</span>&gt;登录&lt;<span class="regexp">/router-link&gt; /</span><span class="regexp">/ tag 可以通过配置 tag 属性生成别的标签</span></span><br><span class="line"><span class="regexp">&lt;router-link tag=&quot;div&quot; to=&quot;/</span>register<span class="string">&quot;&gt;注册&lt;/router-link&gt;</span></span><br></pre></td></tr></table></figure>
<p>3、使用 router-view 组件来显示匹配到的组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
<p>4、创建组件<br>5、创建一个路由 router 实例，通过 routes 属性来定义路由匹配规则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; </span><br><span class="line">      path: <span class="string">&#x27;/login&#x27;</span>, </span><br><span class="line">      component: login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; </span><br><span class="line">      path: <span class="string">&#x27;/register&#x27;</span>, </span><br><span class="line">      component: register </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>6、使用 router 属性来使用路由规则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router: router <span class="comment">// 使用 router 属性来使用路由规则 可缩写为 router</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="三、Vue-Router-高级用法"><a href="#三、Vue-Router-高级用法" class="headerlink" title="三、Vue Router 高级用法?"></a>三、Vue Router 高级用法?</h2><h4 id="1、动态路由匹配"><a href="#1、动态路由匹配" class="headerlink" title="1、动态路由匹配"></a>1、动态路由匹配</h4><p> 1）在路由规则中定义参数<br> 2）通过 this.$route.params来获取路由中的参数<br> 3）当使用路由参数时，例如从 /user/id1 导航到 /user/id2，原来的组件实例会被复用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。<br> 4）复用组件时，想对路由参数的变化作出响应的话，可以简单地 watch (监测变化) $route 对象 </p>
<h4 id="2、使用-children-属性实现路由嵌套-（路由路径会自动拼接）"><a href="#2、使用-children-属性实现路由嵌套-（路由路径会自动拼接）" class="headerlink" title="2、使用 children 属性实现路由嵌套 （路由路径会自动拼接）"></a>2、使用 children 属性实现路由嵌套 （路由路径会自动拼接）</h4><h4 id="3、导航钩子"><a href="#3、导航钩子" class="headerlink" title="3、导航钩子"></a>3、导航钩子</h4><h2 id="四、hash和history两种模式的区别"><a href="#四、hash和history两种模式的区别" class="headerlink" title="四、hash和history两种模式的区别"></a>四、hash和history两种模式的区别</h2><h3 id="1、hash模式"><a href="#1、hash模式" class="headerlink" title="1、hash模式"></a>1、hash模式</h3><p>1.1 这里的 hash 就是指 url 尾巴后的 # 号以及后面的字符。这里的 # 和 css 里的 # 是一个意思。hash 也称作锚点，本身是用来做页面定位的，她可以使对应 id 的元素显示在可视区域内。<br>1.2 由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制，所以人们在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的。<br>1.3 hash模式的原理是onhashchange事件,可以在window对象上监听这个事件。<br>1.4、hash 能兼容到IE8</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.location.hash = <span class="string">&#x27;qq&#x27;</span> <span class="comment">// 设置 url 的 hash，会在当前url后加上 &#x27;#qq&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hash = <span class="built_in">window</span>.location.hash <span class="comment">// &#x27;#qq&#x27;  </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">// 监听hash变化，点击浏览器的前进后退会触发</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2、history模式"><a href="#2、history模式" class="headerlink" title="2、history模式"></a>2、history模式</h3><p>2.1  history api可以分为两大部分，切换和修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.go(<span class="number">-2</span>);<span class="comment">//后退两次</span></span><br><span class="line">history.go(<span class="number">2</span>);<span class="comment">//前进两次</span></span><br><span class="line">history.back(); <span class="comment">//后退</span></span><br><span class="line">hsitory.forward(); <span class="comment">//前进</span></span><br></pre></td></tr></table></figure>
<p>2.2 修改历史状态包括了pushState,replaceState</p>
<p>这两个方法接收三个参数:stateObj,title,url</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>&#125;, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">history.back();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     history.forward();</span><br><span class="line"> &#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">window</span>.onpopstate = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(event.state)</span><br><span class="line">     <span class="keyword">if</span>(event.state &amp;&amp; event.state.color === <span class="string">&#x27;red&#x27;</span>)&#123;</span><br><span class="line">           <span class="built_in">document</span>.body.style.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过pushstate把页面的状态保存在state对象中，当页面的url再变回这个url时，可以通过event.state取到这个state对象，从而可以对页面状态进行还原，这里的页面状态就是页面字体颜色，其实滚动条的位置，阅读进度，组件的开关等这些页面状态都可以存储到state的里面。</p>
<p>2.3 存在问题：自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会出现404</p>
<p>2.4 这种模式要玩好，还需要后台配置支持。对于一般的 Vue + Vue-Router + Webpack + XXX 形式的 Web 开发场景，用 history 模式即可，只需在后端（Apache 或 Nginx）进行简单的路由配置，同时搭配前端路由的 404 页面支持。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2020/08/22/5.3.2%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20Vue-Router/" data-id="ckefjrl9z000ks0sxh1i42mjj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/vue-%E5%85%A8%E5%AE%B6%E6%A1%B6/" rel="tag">vue 全家桶</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-5.3 vue 全家桶" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/5.3%20vue%20%E5%85%A8%E5%AE%B6%E6%A1%B6/" class="article-date">
  <time datetime="2020-05-10T14:13:26.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/5.3%20vue%20%E5%85%A8%E5%AE%B6%E6%A1%B6/">vue 全家桶</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="链接网址">全家桶之 vuex</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2020/05/10/5.3%20vue%20%E5%85%A8%E5%AE%B6%E6%A1%B6/" data-id="ckefjrl9x000gs0sxfpmx34r3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/vue-%E5%85%A8%E5%AE%B6%E6%A1%B6/" rel="tag">vue 全家桶</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-5.3.1 全家桶之 vuex " class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/10/5.3.1%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20vuex%20/" class="article-date">
  <time datetime="2020-05-10T14:13:26.000Z" itemprop="datePublished">2020-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/10/5.3.1%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20vuex%20/">全家桶之 Vuex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、什么是-Vuex"><a href="#一、什么是-Vuex" class="headerlink" title="一、什么是 Vuex?"></a>一、什么是 Vuex?</h2><p>官方的解释： Vuex是一个专为Vue.js应用程序开发的状态管理模式<br>简单的说：可以理解为整个Vue程序中的全局变量。</p>
<h2 id="二、为什么要用-Vuex"><a href="#二、为什么要用-Vuex" class="headerlink" title="二、为什么要用 Vuex?"></a>二、为什么要用 Vuex?</h2><p>应用场景：单页应用中，组件之间的数据状态。<br>优点：<br>1、当项目比较庞大的时候，每个组件的状态比较多，用了Vuex多层嵌套的组件、兄弟组件间的状态会更好管理维护。<br>2、缓存一些当前要使用请求远程或本地的数据集（刷新后会自己销毁）。<br>3、在2的基础上可以减少向服务器的请求，节省资源。 用户越多，资源节省越可观。<br>4、对开发者来说，如果你的项目足够复杂，团队的规模也不仅是一个人，数据集中处理更利于程序的稳定和维护。  </p>
<h2 id="三、Vuex-特点"><a href="#三、Vuex-特点" class="headerlink" title="三、Vuex 特点?"></a>三、Vuex 特点?</h2><p>1、响应式更新；<br>2、不能直接修改Vuex中的变量，只能通过显式地commit=&gt;mutation来进行数据的改变；</p>
<h2 id="四、如何使用-Vuex"><a href="#四、如何使用-Vuex" class="headerlink" title="四、如何使用 Vuex?"></a>四、如何使用 Vuex?</h2><h3 id="1、使用npm安装-npm-i-vuex-s"><a href="#1、使用npm安装-npm-i-vuex-s" class="headerlink" title="1、使用npm安装: npm i vuex -s"></a>1、使用npm安装: npm i vuex -s</h3><h3 id="2、初级用法"><a href="#2、初级用法" class="headerlink" title="2、初级用法"></a>2、初级用法</h3><p>2.1 在项目的根目录下新增一个store文件夹，在该文件夹内创建index.js<br>2.2 初始化store下index.js中的内容</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载Vuex</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Vuex对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        <span class="comment">//存放的键值对就是所要管理的状态</span></span><br><span class="line">        name:<span class="string">&#x27;baiyun&#x27;</span>,</span><br><span class="line">        age: <span class="string">&#x27;18&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">      saveName(nameVal)&#123;</span><br><span class="line">        state.name = nameVal</span><br><span class="line">      &#125;,</span><br><span class="line">      saveAge(ageVal)&#123;</span><br><span class="line">        state.age = ageVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>2.3 在main.js 将store挂载到当前项目的Vue实例当中去</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,  <span class="comment">//store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>2.4 在组件中使用Vuex: $store.state.name</p>
<h3 id="3、高级用法"><a href="#3、高级用法" class="headerlink" title="3、高级用法"></a>3、高级用法</h3><p>在初级用法中，我们把所有东西都写在一个文件中，这样数据多的时候，耦合度太高，也不便于维护，而且mutations也不能解决异步问题，这里就介绍另一种方式以及actions（间接触发mutations方法的一种 “ 中间商 “，而且它可以执行异步操作，避免用户去直接操作state）。在src目录中，创建store文件，并创建Vuex中模块的文件名，每一个都单独拆分开，便于管理模块。<br>规范目录结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store:.</span><br><span class="line">│  actions.js</span><br><span class="line">│  getters.js</span><br><span class="line">│  index.js</span><br><span class="line">│  mutations.js</span><br><span class="line">│  mutations_type.js   ##该项为存放mutaions方法常量的文件，按需要可加入</span><br><span class="line">│</span><br><span class="line">└─modules</span><br><span class="line">        index.js</span><br></pre></td></tr></table></figure>

<p>一共涉及5种属性：State、 Getter、Mutation 、Action、 Module</p>
<p>3.1 把Vuex看成一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data。state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新。 </p>
<p>state.js ：保存所有数据，以对象的方式导出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name:<span class="string">&#x27;baiyun&#x27;</span>, -- 默认值</span><br><span class="line">  age: <span class="string">&#x27;18&#x27;</span> -- 默认值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.2 getters 可以对State进行计算操作，它就是Store的计算属性。虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用。如果一个状态只在一个组件内使用，是可以不用getters。<br>getters.js: 对state中的成员加工后传递给外界。<br>Getters中的方法有两个默认参数:<br> 1）state 当前Vuex对象中的状态对象<br> 2）getters 当前getters对象，用于将getters下的其他getter拿来用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getters:&#123;</span><br><span class="line">    nameInfo(state)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;姓名:&quot;</span>+state.name</span><br><span class="line">    &#125;,</span><br><span class="line">    ageInfo(state,getters)&#123;</span><br><span class="line">        <span class="keyword">return</span> getters.nameInfo+<span class="string">&#x27;年龄:&#x27;</span>+state.age</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件中调用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.getters.fullInfo</span><br></pre></td></tr></table></figure>

<p>3.3、mutations.js ：保存所有方法，用来改变state的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前姓名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> saveName = <span class="function">(<span class="params">state, name</span>) =&gt;</span> &#123;</span><br><span class="line">  state.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存当前年龄</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> saveAge = <span class="function">(<span class="params">state, age</span>) =&gt;</span> &#123;</span><br><span class="line">  state.age = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.4 actions中的方法有两个默认参数:<br> 1）context 上下文(相当于箭头函数中的this)对象<br> 2）payload 挂载参数<br>actions.js ：暴露给用户使用，借此触发mutations中的方法，保存数据（可执行异步操作）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交当前姓名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> saveName = <span class="function">(<span class="params">&#123; commit &#125;, name</span>) =&gt;</span> &#123;</span><br><span class="line">  commit(<span class="string">&#x27;savePath&#x27;</span>, name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交当前年龄</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> saveAge = <span class="function">(<span class="params">&#123; commit &#125;, age</span>) =&gt;</span> &#123;</span><br><span class="line">  commit(<span class="string">&#x27;saveAge&#x27;</span>, age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在组件中调用:this.$store.dispatch(‘saveName’,{age:15})</p>
<p>3.5 index.js：引入相应模块，暴露出store，供vue注册后全局使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">&#x27;./actions&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> mutations <span class="keyword">from</span> <span class="string">&#x27;./mutations&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  actions,</span><br><span class="line">  mutations</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>3.6 main.js中引入index.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入vuex-store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>3.7 保存数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;Vuex&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2种方式</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 方法一（dispatch）: 通过disptach派发给actions，让actions去触发</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;saveName&#x27;</span>, <span class="built_in">this</span>.DbSource);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 方法二（映射）</span></span><br><span class="line"><span class="comment">// 1、通过methods方法添加映射关系 : 通过在methods中添加映射关系，数组方式，我们可以在数组中写多个方法（这里数组中的每一个方法名是actions.js文件中所定义的方法名）, 然后在需要使用的地方直接this.方法名即可。 当然，也可以直接绑定给html中的某个事件。值的注意的是，避免和methods中自己定义的其他方法的名字冲突</span></span><br><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([<span class="string">&#x27;saveName&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// 2、使用 </span></span><br><span class="line"><span class="built_in">this</span>.saveName</span><br></pre></td></tr></table></figure>
<p>3.8 数据获取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;Vuex&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;saveName&#x27;</span>]),</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">    saveName(currVal) &#123;</span><br><span class="line">        <span class="comment">// 监听mapState中的变量，当数据变化（有值、值改变等），</span></span><br><span class="line">        <span class="comment">// 保证能拿到完整的数据，不至于存在初始化没有数据的问题，然后可以赋给本组件data中的变量</span></span><br><span class="line">      <span class="built_in">this</span>.currVal = currVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、Vuex-namespaced的作用以及使用方式"><a href="#4、Vuex-namespaced的作用以及使用方式" class="headerlink" title="4、Vuex namespaced的作用以及使用方式"></a>4、Vuex namespaced的作用以及使用方式</h3><p>Vuex中的store分模块管理，需要在store的index.js中引入各个模块，为了解决不同模块命名冲突的问题，将不同模块的namespaced:true，之后在不同页面中引入getter、actions、mutations时，需要加上所属的模块名<br>4.1 声明分模块的store时加上namespaced:true<br>4.2 使用模块中的mutations、getters、actions时候，要加上模块名，例如使用commint执行mutations时, 格式：模块名/模块中的mutations<br>4.3、获取属性时同样加上模块名,格式：$store.state.模块名.模块属性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2020/05/10/5.3.1%20%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%B9%8B%20vuex%20/" data-id="ckefjrl9w000es0sx7ox5g5rv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/vue-%E5%85%A8%E5%AE%B6%E6%A1%B6/" rel="tag">vue 全家桶</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-1.2 总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/05/05/1.2%20%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-05-05T13:55:53.000Z" itemprop="datePublished">2020-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/05/05/1.2%20%E6%80%BB%E7%BB%93/">20200505总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="1、水印渲染"><a href="#1、水印渲染" class="headerlink" title="1、水印渲染"></a>1、水印渲染</h6><h6 id="2、多语言生成"><a href="#2、多语言生成" class="headerlink" title="2、多语言生成"></a>2、多语言生成</h6><p>3、复制页面后没有删除无用代码（js引用、页面属性）、命名未修改</p>
<p>4、页面注释有问题（pagecode 写成 functioncode,方法注释与实际参数不一致）</p>
<p>5、部分方法重复，可提取</p>
<p>6、注释较少</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2020/05/05/1.2%20%E6%80%BB%E7%BB%93/" data-id="ckefjrl9j0002s0sxhw1n2ayx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/my-review/" rel="tag">my review</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-4.2 微前端相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/04/16/4.2%20%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-04-16T13:14:31.000Z" itemprop="datePublished">2020-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/04/16/4.2%20%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/">微前端相关(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>背景及问题<br>站点是由多站点组合架构，每个站点都由SPA架构。站点间的跳转都是通过href跳转，这样就导致有如下几点缺点：</p>
<p>1、公共组件代码没法抽离<br>2、公共导航和布局不能共用<br>3、无法保证单页应用的体验</p>
<p>技术选型<br>市面上所有微前端开发的子应用技术栈都无限制。</p>
<p>Nginx的路由分发规则</p>
<p>该规则要有特点的私有前缀，同时增应用得配置Nginx配置文件</p>
<p>Iframe嵌入</p>
<p>页面刷新无法保证子应用的路由状态，同时Iframe适配存在问题</p>
<p>SingleSPA</p>
<p>所有资源文件打包成JS，无法并行加载，全局变量污染，样式污染，监听污染</p>
<p>qiankun</p>
<p>基于SingleSPA，同时集成JS运行时沙箱和样式隔离，完全的无技术栈依赖</p>
<p>icestark</p>
<p>无基础依赖，但是主应用必须基于React开发</p>
<p>综合上述问题，采用qiankun方案作为微前端架构基础。</p>
<p>主框架<br>1、安装</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qiankun --save</span><br></pre></td></tr></table></figure>

<p>2、主应用配置<br>在入口文件增加以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerMicroApps, start &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// register the sub apps</span></span><br><span class="line">registerMicroApps([</span><br><span class="line">&#123;</span><br><span class="line">    name: <span class="string">&#x27;vueApp&#x27;</span>,</span><br><span class="line">    entry: <span class="string">&#x27;//localhost:7100&#x27;</span>, <span class="comment">// 子应用网站地址</span></span><br><span class="line">    container: <span class="string">&#x27;#container&#x27;</span>,</span><br><span class="line">    activeRule: <span class="string">&#x27;/vue&#x27;</span>,</span><br><span class="line">    props: &#123;&#125; <span class="comment">// 自定义通信用数据接口，实现模块等下发</span></span><br><span class="line">&#125;</span><br><span class="line">]);</span><br><span class="line"> </span><br><span class="line">start();</span><br></pre></td></tr></table></figure>
<p>3、子应用配置<br>webpack配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> packageName = <span class="built_in">require</span>(<span class="string">&#x27;./package.json&#x27;</span>).name;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        library: <span class="string">`<span class="subst">$&#123;packageName&#125;</span>-[name]`</span>,</span><br><span class="line">        libraryTarget: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">        jsonpFunction: <span class="string">`webpackJsonp_<span class="subst">$&#123;packageName&#125;</span>`</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>入口文件增加钩子函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;app bootstraped&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123; <span class="comment">// 接收父组件注册时props参数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(props));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;update props&#x27;</span>, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、应用间通信</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initGlobalState &#125; <span class="keyword">from</span> <span class="string">&#x27;qiankun&#x27;</span></span><br><span class="line"><span class="keyword">const</span> &#123; onGlobalStateChange, setGlobalState &#125; = initGlobalState(&#123; <span class="comment">// 主应用注册全局状态，再将示例下发给各个子应用</span></span><br><span class="line">  msg: <span class="string">&#x27;消息&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">setGlobalState(&#123; <span class="attr">msg</span>: <span class="string">&#x27;消息&#x27;</span> &#125;); <span class="comment">// 触发变更</span></span><br><span class="line">onGlobalStateChange(<span class="function">(<span class="params">value, prev</span>) =&gt;</span> &#123; <span class="comment">// 监听变更</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[onGlobalStateChange]:&#x27;</span>, value, prev);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>5、在已发布的主网站调试本地子站项目<br>假设子站的配置信息如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sites = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    entry: <span class="string">&#x27;//localhost:8001&#x27;</span>,</span><br><span class="line">    container: <span class="string">&#x27;#main&#x27;</span>,</span><br><span class="line">    activeRule: <span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>6、可以通过在localstorage中加入自定义变量的方式将子应用的地址改成本地：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> customSetting = &#123;&#125;</span><br><span class="line">  customSetting.app = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">  customSetting.entry = <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;entry&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123;app, entry&#125; = customSetting</span><br><span class="line">  <span class="keyword">if</span>(app &amp;&amp; entry) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = sites.find(<span class="function"><span class="params">node</span> =&gt;</span> node.name === app)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;find&#x27;</span>, item)</span><br><span class="line">    <span class="keyword">if</span>(item) &#123;</span><br><span class="line">      item.entry = entry;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、注意点：<br>主应用的容器id不能与子应用的容器id相同 ，vue脚手架生成的项目容器id为app,  框架的容器id需要修改为不同的值<br>子项目存在异步加载的js时要将publicPath设置为实际的域名<br>子应用可以通过window.<strong>POWERED_BY_QIANKUN</strong>变量判断是否时从乾坤框架加载<br>部署时子应用网站需要设置Access-Control-Allow-Origin请求体，不然请求子应用静态资源时会失败<br>activeRule传入字符串或者数组时，浏览器传入地址的pathname必须以’/‘结尾，否则无法匹配，使用函数方式则没有这个问题 ： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activeRule: <span class="function"><span class="params">location</span> =&gt;</span> location.pathname.startsWith(<span class="string">&#x27;/vue&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>qiankun加载微应用的模式为history模式，所以需要进行服务器配置, 以nginx为例： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">8002</span>;</span><br><span class="line"> </span><br><span class="line">    server_name localhost;</span><br><span class="line"> </span><br><span class="line">    location / &#123;</span><br><span class="line"> </span><br><span class="line">        root /Volumes/aigo/qiankun_demo/mainapp/dist;</span><br><span class="line"> </span><br><span class="line">        index index.html index.htm;</span><br><span class="line"> </span><br><span class="line">        try_files $uri $uri/ /index.html;  # 重点，让服务器端对该网站的响应都为index.html</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置sandbox为{ strictStyleIsolation: true }时，子应用挂载元素需要做特殊处理，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render(props) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = (props &amp;&amp; props.container &amp;&amp; props.container.nodeType === <span class="number">11</span>) ? props.container.querySelector(<span class="string">&#x27;#app&#x27;</span>) : <span class="string">&#x27;#app&#x27;</span></span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el,</span><br><span class="line">        router,</span><br><span class="line">        components: &#123; App &#125;,</span><br><span class="line">        template: <span class="string">&#x27;&lt;App /&gt;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子应用在开发时需要直接与主框架联调，为了解决跨域问题，需要设置 ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2020/04/16/4.2%20%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/" data-id="ckefjrl9y000is0sx8rkh37fv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-4.1 微前端相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2020/04/16/4.1%20%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2020-04-16T13:05:09.000Z" itemprop="datePublished">2020-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2020/04/16/4.1%20%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/">微前端相关（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>微服务之间中转白屏问题；<br>主框架里放通用的组件集合(比如：导航)，在子项目里无需再引入，子项目只关心自己的业务就可以；<br>乾坤（最低 IE 版本为 11）：<br>        简单<br>        任意 js 框架均可使用。子应用接入像使用接入一个 iframe 系统一样简单，但实际不是 iframe。</p>
<pre><code>    完备
    几乎包含所有构建微前端系统时所需要的基本能力，如 样式隔离、js 沙箱、预加载等。

    生产可用
    已在蚂蚁内外经受过足够大量的线上系统的考验及打磨，健壮性值得信赖(200多个线上应用用接入)

    官网：https://qiankun.umijs.org/zh/</code></pre><p>飞冰（主项目必须以React，最低 IE 版本为 11）：<br>        框架应用只需依赖 npm 包 @ice/stark，不耦合任何工程体系</p>
<pre><code>    接入简单，子应用支持 React/Vue/Angular... 等不同框架

    子应用独立开发、不耦合任何工程体系，已有应用迁移成本极低

    整个系统用户体验好，跟 SPA 应用基本一致

    子应用只需发布前端资源 bundle 即可，框架应用通过 bundle 渲染子应用
    不足
    样式只能通过约定以及CSS Modules来与框架隔离
    资源无法预加载
    生产可用
    已在阿里创作者平台、阿里健康-熙牛医疗云医院信息系统、淘系小二工作台
    官网：https://ice.work/docs/icestark/about</code></pre><p>H5导航接入：</p>
<p>头部导航和底部的导航主站会统一引用，接入乾坤后需要子应用通知主应用页面路由的变化。<br>各微服务原页面内引用的导航不需要删除，导航组件会根据环境自动选择加不加载<br>接入方法：<br>1、原mount 方法内处理乾坤路由的方法多接受2个参数setGlobalState, state，用于父子通信</p>
<pre><code class="javascript">export async function mount ({ data = {}, ROUTES, routerBase, state, setGlobalState } = {}) {
if (!routerBase) return


setLanguage().then(() =&gt; {
instance = new Vue({
router: getQkRouter(routerBase, setGlobalState, state),
store,
i18n,
render: h =&gt;
h(App, {
props: { ...data, ...state }
        })
    }).$mount(&#39;#app_decorate&#39;)
  })
}</code></pre>
<p>2、获取乾坤配置的路由内在路由跳转时发送消息通知父应用</p>
<pre><code class="javascript">router.afterEach
/**
 * 获取乾坤路由配置
 * @param {string} base 路由前缀
 */
export const getQkRouter = (base, setGlobalState, state) =&gt; {
  const subSiteRoutes = routesAll.map(r =&gt; {
    r.path = base + r.path
    return r
  })
  router.addRoutes(subSiteRoutes)
  router.afterEach((route) =&gt; {
    state.msgType = 0
    state.msg = &#39;路由跳转&#39;
    state.route = route
    setGlobalState(state)
  })
  return router
}</code></pre>
<p>3、页面的路由根据需求加入meta参数开启关闭导航（isShowHeader， isShowFooter）</p>
<pre><code class="javascript">routes
{
   path: &#39;/index&#39;,
   name: &#39;index&#39;,
   component: () =&gt; import(&#39;@/views/index/index&#39;),
   meta: {
     permission: &#39;&#39;,
     title: &#39;首页&#39;,
     vcode: vcodes.app_course,
     functionCode: &#39;decorate_index_m&#39;,
     page_id: &#39;decorate_index_m&#39;,
     isShowHeader: true,
     isShowFooter: true
   }
 }</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2020/04/16/4.1%20%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/" data-id="ckefjrl9r0009s0sx9ciz2ipb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-6 性能优化相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/07/22/6%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2019-07-22T15:28:52.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/07/22/6%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/">如何优化页面性能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、什么是性能？"><a href="#一、什么是性能？" class="headerlink" title="一、什么是性能？"></a>一、什么是性能？</h2><h4 id="1、直观体现："><a href="#1、直观体现：" class="headerlink" title="1、直观体现："></a>1、直观体现：</h4><p>页面加载、操作的流畅度</p>
<h4 id="2、评判指标："><a href="#2、评判指标：" class="headerlink" title="2、评判指标："></a>2、评判指标：</h4><p>业界常用的指标是白屏、首屏、可交互时间和整页时间四个指标。我们可以通过performance API获取到响应的指标值。</p>
<h5 id="2-1-白屏"><a href="#2-1-白屏" class="headerlink" title="2.1 白屏"></a>2.1 白屏</h5><p>指页面接收首字节时长(TTFB: time to first byte)。从浏览器发起请求到开始显示第一个页面元素的时间。现代浏览器不会等待CSS树（所有CSS文件下载和解析完成）和DOM树（整个body标签解析完成）构建完成才开始绘制，而是马上开始显示中间结果。所以经常在低网速的环境中，观察到页面由上至下缓慢显示完，或者先显示文本内容后再重绘成带有格式的页面内容。</p>
<h5 id="2-2-首屏"><a href="#2-2-首屏" class="headerlink" title="2.2 首屏"></a>2.2 首屏</h5><p>首屏时间（FirstScreen Time），是指用户看到第一屏，即整个网页顶部大小为当前窗口的区域，显示完整的时间。常用的方法有，页面标签标记法、图像相似度比较法和首屏高度内图片加载法。</p>
<h5 id="2-3-可交互时间（domready）"><a href="#2-3-可交互时间（domready）" class="headerlink" title="2.3 可交互时间（domready）"></a>2.3 可交互时间（domready）</h5><p>用户可以进行正常的点击、输入等操作，默认可以统计DOMContentLoaded事件发生的时间。</p>
<h5 id="2-4-整页时间"><a href="#2-4-整页时间" class="headerlink" title="2.4 整页时间"></a>2.4 整页时间</h5><p>整页时间（Page Load Time），页面所有资源都加载完成并呈现出来所花的时间，这个就是load事件发生的时间。</p>
<h2 id="二、如何提高性能"><a href="#二、如何提高性能" class="headerlink" title="二、如何提高性能"></a>二、如何提高性能</h2><h4 id="1、资源压缩合并，减少HTTP请求"><a href="#1、资源压缩合并，减少HTTP请求" class="headerlink" title="1、资源压缩合并，减少HTTP请求"></a>1、资源压缩合并，减少HTTP请求</h4><p>html 压缩、css 压缩、js 的压缩和混乱和文件合并。 资源压缩可以从文件中去掉多余的字符，比如回车、空格。</p>
<h4 id="2、非核心代码异步加载"><a href="#2、非核心代码异步加载" class="headerlink" title="2、非核心代码异步加载"></a>2、非核心代码异步加载</h4><p>异步加载的三种方式—— 动态脚本创建、async 和 defer</p>
<h4 id="3、使用浏览器缓存"><a href="#3、使用浏览器缓存" class="headerlink" title="3、使用浏览器缓存"></a>3、使用浏览器缓存</h4><h5 id="3-1-强缓存"><a href="#3-1-强缓存" class="headerlink" title="3.1 强缓存"></a>3.1 强缓存</h5><p>不向服务器发请求，直接从本地硬盘或内存中获取。利用HTTP响应报文中的Expires和Cache-Control两个字段来控制，表示资源的缓存时间。<br>Expires:该字段是HTTP/1.0的规范，是一个绝对时间的GMT格式，这个时间代表资源的失效时间，在该时间内即：命中强缓存。缺点：当客户端与服务器时间出现较大偏差，就会出现混乱。<br>Cache-Control:为了解决Expires出现的问题，HTTP/1.1添加了Cache-Control。主要是利用max-age来进行判断，是一个相对时间。如：Cache-Control:max-age=600,代表着资源的有效期是600秒。</p>
<h5 id="3-1-协商缓存"><a href="#3-1-协商缓存" class="headerlink" title="3.1 协商缓存"></a>3.1 协商缓存</h5><p>向服务器发出验证，如果资源无更改，不重新返回资源内容，资源内容从本地获取。需要有服务器来确定客户端缓存资源是否可用。主要涉及Header中两个字段：Last-Modified/If-Modified-Since或ETag/If-None-Match,这两种字段都是成对出现的。若第一次响应头没有Last-Modified或ETag，则后续的请求头部也不会有If-Modified-Since或If-None-Match。</p>
<h4 id="4、使用CDN"><a href="#4、使用CDN" class="headerlink" title="4、使用CDN"></a>4、使用CDN</h4><h4 id="5、预解析DNS"><a href="#5、预解析DNS" class="headerlink" title="5、预解析DNS"></a>5、预解析DNS</h4><h4 id="6、按需加载"><a href="#6、按需加载" class="headerlink" title="6、按需加载"></a>6、按需加载</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2019/07/22/6%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/" data-id="ckefjrla2000qs0sxafr581oo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-1.3 ASP-NET学习相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019/05/10/1.3%20ASP-NET%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/" class="article-date">
  <time datetime="2019-05-10T13:17:23.000Z" itemprop="datePublished">2019-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2019/05/10/1.3%20ASP-NET%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/">ASP .NET学习相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1、数据返回格式定义：实体一一对应<br>2、表单控件：在前端选择了某种事件，可以自动在后台生成事件方法<br>3、序列化实体对象<br>        即使窗口：1）YXT.Framework.StringUtil.JsonSerialize(entity)<br>                  2）BizUtil.ToU<br>4、获取地址参数：   GetQueryString(“t”)        getQueryString(“t”)<br>5、开启远程：控制面板  -&gt;系统与安全-&gt;系统-&gt;远程设置</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2019/05/10/1.3%20ASP-NET%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/" data-id="ckefjrl9p0005s0sxf9jqhcni" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ASP-NET/" rel="tag">ASP.NET</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-7.1 CSS之绝对定位与相对定位" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/07/22/7.1%20CSS%E4%B9%8B%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/" class="article-date">
  <time datetime="2018-07-22T12:05:12.000Z" itemprop="datePublished">2018-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018/07/22/7.1%20CSS%E4%B9%8B%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/">7.1 CSS之绝对定位与相对定位</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、什么是性能？"><a href="#一、什么是性能？" class="headerlink" title="一、什么是性能？"></a>一、什么是性能？</h2><h4 id="1、直观体现："><a href="#1、直观体现：" class="headerlink" title="1、直观体现："></a>1、直观体现：</h4><p>页面加载、操作的流畅度</p>
<h4 id="2、评判指标："><a href="#2、评判指标：" class="headerlink" title="2、评判指标："></a>2、评判指标：</h4><p>业界常用的指标是白屏、首屏、可交互时间和整页时间四个指标。我们可以通过performance API获取到响应的指标值。</p>
<h5 id="2-1-白屏"><a href="#2-1-白屏" class="headerlink" title="2.1 白屏"></a>2.1 白屏</h5><p>指页面接收首字节时长(TTFB: time to first byte)。从浏览器发起请求到开始显示第一个页面元素的时间。现代浏览器不会等待CSS树（所有CSS文件下载和解析完成）和DOM树（整个body标签解析完成）构建完成才开始绘制，而是马上开始显示中间结果。所以经常在低网速的环境中，观察到页面由上至下缓慢显示完，或者先显示文本内容后再重绘成带有格式的页面内容。</p>
<h5 id="2-2-首屏"><a href="#2-2-首屏" class="headerlink" title="2.2 首屏"></a>2.2 首屏</h5><p>首屏时间（FirstScreen Time），是指用户看到第一屏，即整个网页顶部大小为当前窗口的区域，显示完整的时间。常用的方法有，页面标签标记法、图像相似度比较法和首屏高度内图片加载法。</p>
<h5 id="2-3-可交互时间（domready）"><a href="#2-3-可交互时间（domready）" class="headerlink" title="2.3 可交互时间（domready）"></a>2.3 可交互时间（domready）</h5><p>用户可以进行正常的点击、输入等操作，默认可以统计DOMContentLoaded事件发生的时间。</p>
<h5 id="2-4-整页时间"><a href="#2-4-整页时间" class="headerlink" title="2.4 整页时间"></a>2.4 整页时间</h5><p>整页时间（Page Load Time），页面所有资源都加载完成并呈现出来所花的时间，这个就是load事件发生的时间。</p>
<h2 id="二、如何提高性能"><a href="#二、如何提高性能" class="headerlink" title="二、如何提高性能"></a>二、如何提高性能</h2><h4 id="1、资源压缩合并，减少HTTP请求"><a href="#1、资源压缩合并，减少HTTP请求" class="headerlink" title="1、资源压缩合并，减少HTTP请求"></a>1、资源压缩合并，减少HTTP请求</h4><p>html 压缩、css 压缩、js 的压缩和混乱和文件合并。 资源压缩可以从文件中去掉多余的字符，比如回车、空格。</p>
<h4 id="2、非核心代码异步加载"><a href="#2、非核心代码异步加载" class="headerlink" title="2、非核心代码异步加载"></a>2、非核心代码异步加载</h4><p>异步加载的三种方式—— 动态脚本创建、async 和 defer</p>
<h4 id="3、使用浏览器缓存"><a href="#3、使用浏览器缓存" class="headerlink" title="3、使用浏览器缓存"></a>3、使用浏览器缓存</h4><h5 id="3-1-强缓存"><a href="#3-1-强缓存" class="headerlink" title="3.1 强缓存"></a>3.1 强缓存</h5><p>不向服务器发请求，直接从本地硬盘或内存中获取。利用HTTP响应报文中的Expires和Cache-Control两个字段来控制，表示资源的缓存时间。<br>Expires:该字段是HTTP/1.0的规范，是一个绝对时间的GMT格式，这个时间代表资源的失效时间，在该时间内即：命中强缓存。缺点：当客户端与服务器时间出现较大偏差，就会出现混乱。<br>Cache-Control:为了解决Expires出现的问题，HTTP/1.1添加了Cache-Control。主要是利用max-age来进行判断，是一个相对时间。如：Cache-Control:max-age=600,代表着资源的有效期是600秒。</p>
<h5 id="3-1-协商缓存"><a href="#3-1-协商缓存" class="headerlink" title="3.1 协商缓存"></a>3.1 协商缓存</h5><p>向服务器发出验证，如果资源无更改，不重新返回资源内容，资源内容从本地获取。需要有服务器来确定客户端缓存资源是否可用。主要涉及Header中两个字段：Last-Modified/If-Modified-Since或ETag/If-None-Match,这两种字段都是成对出现的。若第一次响应头没有Last-Modified或ETag，则后续的请求头部也不会有If-Modified-Since或If-None-Match。</p>
<h4 id="4、使用CDN"><a href="#4、使用CDN" class="headerlink" title="4、使用CDN"></a>4、使用CDN</h4><h4 id="5、预解析DNS"><a href="#5、预解析DNS" class="headerlink" title="5、预解析DNS"></a>5、预解析DNS</h4><h4 id="6、按需加载"><a href="#6、按需加载" class="headerlink" title="6、按需加载"></a>6、按需加载</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/blossomsun/blog/2018/07/22/7.1%20CSS%E4%B9%8B%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E4%B8%8E%E7%9B%B8%E5%AF%B9%E5%AE%9A%E4%BD%8D/" data-id="ckefjrla1000ns0sxdlokb4e3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/css/" rel="tag">css</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/ASP-NET/" rel="tag">ASP.NET</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/css/" rel="tag">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/my-review/" rel="tag">my review</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/vue-%E5%85%A8%E5%AE%B6%E6%A1%B6/" rel="tag">vue 全家桶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E4%BE%BF%E6%8D%B7%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9/" rel="tag">便捷的第三方</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/" rel="tag">兼容问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" rel="tag">微前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/" rel="tag">杂七杂八的小问题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/ASP-NET/" style="font-size: 10px;">ASP.NET</a> <a href="/blog/tags/css/" style="font-size: 10px;">css</a> <a href="/blog/tags/my-review/" style="font-size: 10px;">my review</a> <a href="/blog/tags/vue/" style="font-size: 15px;">vue</a> <a href="/blog/tags/vue-%E5%85%A8%E5%AE%B6%E6%A1%B6/" style="font-size: 20px;">vue 全家桶</a> <a href="/blog/tags/%E4%BE%BF%E6%8D%B7%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9/" style="font-size: 10px;">便捷的第三方</a> <a href="/blog/tags/%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/" style="font-size: 10px;">兼容问题</a> <a href="/blog/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">微前端</a> <a href="/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/blog/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/" style="font-size: 10px;">杂七杂八的小问题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 blossomsun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>